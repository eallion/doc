\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[www.dreamsafari.info\](https://www.dreamsafari.info/2020/04/hugo-loveit-mod/)

 2020.4.10  2020.7.10  [Hello IT](https://www.dreamsafari.info/categories/hello-it/)  6344  13 分钟

目录
--

1.  [1\. 相关文章](#1-相关文章)
2.  [2\. 全文搜索（Algolia）](#2-全文搜索algolia)
    1.  [2.1 生成索引](#21-生成索引)
    2.  [2.2 上传索引](#22-上传索引)
    3.  [2.3 修改 Algolia 的设置](#23-修改algolia的设置)
    4.  [2.4 和 Netlify 结合](#24-和netlify结合)
    5.  [2.5 为主题增加搜索页](#25-为主题增加搜索页)
3.  [3\. PWA](#3-pwa)
4.  [4\. Disqus 代理](#4-disqus代理)
5.  [5\. 懒人方案](#5-懒人方案)
6.  [6\. 后话](#6-后话)

在[上一篇文章](https://www.dreamsafari.info/2020/03/golden-memories/)里面刚说好不要_**又是一篇技术博客**_，结果，可能我今天就要水一篇了…… 主要原因是觉得用了 [LoveIT](https://github.com/dillonzq/LoveIt) 这个主题之后，觉得还是有点美中不足，所以自己动手修改了一下。修改完了觉得，总得找个地方记录一下，以免，之后自己忘记怎么搞。下面说的修改都以 [LoveIT](https://github.com/dillonzq/LoveIt) 为例，其他的主题可以参照修改。

除非打算提交 PR，否则不建议在主题的文件夹内直接进行修改，不然会给日后更新主题带来很多的麻烦。推荐把主题内需要修改的文件复制到站点根目录对应位置内（例如：/themes/LoveIt/layouts/partials/single/footer.html -> /layouts/partials/single/footer.html）之后进行修改。hugo 在生成站点的时候，会优先使用根目录下的同名文件覆盖主题文件。

[](#1-相关文章)[1\. 相关文章](#contents:1-相关文章)
---------------------------------------

以前用 WordPress 的时候，可以显示相关文章的推荐。我觉得这个功能挺好用的，于是想着我也要增加这个功能。因为 hugo 是全静态的，所以这个实现起来似乎有些难度。google 了一圈发现了这篇文章：[How to show related posts in Hugo](https://novelist.xyz/tech/related-posts-in-hugo/)。看了一下原理，似乎是通过文章的 tag 来实现的。

那就，照着那篇文章里面的代码，稍微修改一下吧：

需要修改的文件是 / layouts/partials/single/footer.html

在合适的位置插入下面代码：

上面的代码默认会显示最多 5 篇相关文章，如果某一篇文章不需要显示相关文章的话，可以在文章的 front matter 中手动输入 "RelatedPosts: false" 来禁用相关文章的显示。

PS. 我后来又发现 [hugo-theme-meme](https://github.com/reuixiy/hugo-theme-meme) 这个主题的 config.toml 里面有相关文章的部分，可以通过文章的分类，标签和发布日期来设定权重，感觉更加全面一些了。

[](#2-全文搜索algolia)[2\. 全文搜索（Algolia）](#contents:2-全文搜索algolia)
--------------------------------------------------------------

感觉这个是最难的部分，我搞了好久好久啊…… 最大的难点就在于，如何生成全文的索引。Algolia 怎么注册什么的，网上铺天盖地都有，就不再赘述了。下面假设已经注册好了 Algolia，同时也已经有了对应的 API Keys。

在 config.toml 里面需要设置下面这些内容：

```
<div class="related-posts">
	{{- if ( .Params.RelatedPosts | default true ) -}}
		</br>
		<b>{{- printf (T "RelatedPosts") -}}</b>
		{{ range first 5 ( where ( where .Site.Pages.ByDate.Reverse ".Params.tags" "intersect" .Params.tags ) "Permalink" "!=" .Permalink ) }}
			<li class="relatedPost">
				<a href="{{ .RelPermalink }}">{{ .Title | markdownify }}</a><br />
				{{ .Description | markdownify }}
			</li>
		{{ end }}
	{{- end -}}
</div>
```

同时，在 \[outputs\] 中，home 增加 Algolia。修改完毕应该长这样：

### [](#21-生成索引)[2.1 生成索引](#contents:21-生成索引)

生成文章的索引是实现搜索的第一步，也是最麻烦的一步。

麻烦的点主要在于，Algolia 免费的服务限制了[每一条记录的大小不能超过 10 KB](https://www.algolia.com/doc/faq/basics/is-there-a-size-limit-for-my-index-records/)。所以，对于一些比较长的文章来说，如果要实现全文索引，那就势必牵涉到如何分割记录这个问题。

Algolia 官方的建议是可以按照每一段来分割记录，并且针对 WordPress 和 Laravel 给出了教程。可惜的是，这些都是针对 PHP 的教程，没法移植到 hugo 上面。我于是 google 了一遍，发现[一个俄罗斯的哥们](https://www.kizu.ru/algolia-search/)写了个 Gulp 脚本，按照副标题来切割记录。然而…… 我很多的文章并没有副标题…… 然后我又发现了[这篇文章](https://www.bennet.org/blog/site-search-jamstack-hugo-algolia/)。这个哥们也跟我有同样的困扰，于是采用了一个机智的方法，利用 delimit 函数，每 1000 个空格截断记录。我尝试了一下，可耻地失败了。失败原因：中文他没有空格啊……

不过虽然照抄代码失败了，思路还是可以借鉴的。机智如我想到：💡英文用空格来截断，主要是为了防止一个单词中途被切开，那中文并没有这个问题啊！我的博客，绝大多数的内容都是中文的，所以，直接截取若干个字符，应该就好了吧！至于为数不多的几篇英文博客，就，抓大放小吧…… 如果有更好的切割长文章的方法，强烈欢迎大家一起讨论。

简单爬了一下 [hugo 的文档](https://gohugo.io/functions/)，发现了 [substr](https://gohugo.io/functions/substr/) 这个函数挺有潜力的。不过似乎 substr 不能用在 Page.PlainWords 上面，没关系，那就改用 Page.Plain 吧。

Page.Plain 得到的结果里面有一些转义的字符需要修改一下。我就直接贴一下[我的模板](https://github.com/dreamsafari/LoveIt/blob/master/layouts/_default/list.algolia.json)吧：

```
\[outputFormats.Algolia\]
  baseName = "algolia"
  isPlainText = true
  mediaType = "application/json"
  notAlternative = true

\[params.algolia\]
  appId = 你的APP ID
  indexName = 你的index名称
  searchOnlyKey = 记得这里只需要Search-Only API Key，不需要Admin API Key。
```

把模板保存为 / layouts/{?\_}defaults/list.algolia.json。运行 hugo 命令之后就会在 / public 文件夹下生成 algolia.json，可以上传到 algolia 了

### [](#22-上传索引)[2.2 上传索引](#contents:22-上传索引)

上传到 algolia 相对来说就比较简单了。我用的是 _atomic-algolia_。首先[安装 npm](https://www.npmjs.com/get-npm)，然后在站点根目录下面运行：

npm init 是用来生成默认的 package.json，基本上一路回车就行了。运行运行完这两个命令之后，打开 package.json 文件，在 "scripts" 这部分增加一句 "algolia": "atomic-algolia"。修改完毕之后应该长这样：

```
\[outputs\]
  home = \["HTML", "RSS", "Algolia"\]
```

完成之后，还需要新建一个. env 的文件，告诉 atomic-algolia 一些信息：

填写并保存之后，可以尝试把索引提交给 Algolia 了：

如果一切正常，那么应该看到的是类似于下面这张图片（我懒得截图，用了上面那个 blog 的截图）：

![](https://www.bennet.org/blog/site-search-jamstack-hugo-algolia/images/5.png)

### [](#23-修改algolia的设置)[2.3 修改 Algolia 的设置](#contents:23-修改algolia的设置)

上传完毕索引之后，还需要在 Algolia 里面设置一下。点击 Indices，然后找到 Configuration 这个 tab。主要修改下面几个选项：

1.  Searchable attributes
    
    这个选项用来告诉 Algolia，在哪些索引里面进行搜索。比如，我不需要 Algolia 在日期和 URL 里面进行搜索（一般人都不需要吧），所以我的选项是 title，tags，content 和 categories。
    
2.  Ranking and Sorting
    
    这个主要是排序，除了 Algolia 自己默认的之外，我还增加了 date。优先显示最近发表的博客。
    
3.  Duplication and Grouping
    
    我们之前把一条博客拆分成了好多条索引，因此默认情况下 Algolia 如果在同一篇博客的不同索引找到了同一个关键词，会把这些索引都显示出来。这就有些没必要了。所以可以在这里进行设置，把 Distinct 设置为 true，然后 Attribute for Distinct 设置为 url，或者 title。
    
4.  Highlighting
    
    这里最重要的是设置搜索结果中高亮的 tag。Algolia 默认用了`<em>`和`</em>`来进行高亮，但是 LoveIt（或者 hugo？）用了这个标签来标记斜体。因此需要修改一下。于是我把标签修改成了`<m>`和`</m>`。
    
5.  记得点 Review and Save Settings 来保存修改
    

### [](#24-和netlify结合)[2.4 和 Netlify 结合](#contents:24-和netlify结合)

每次更新 blog 之后手动生成和上传索引肯定不是一个方便的解决方案。好在我的博客采用了 Netlify 来部署，使用 Netlify 的话使得部署更方便。怎么注册 Netlify，如何把 Netlify 和 GitHub 整合也不是这篇 blog 要 cover 的内容。下面的内容假设你已经可以成功在 Netlify 上面部署博客站点了。

首先，在 settings 的 Build & deploy 里面找到 Environment，然后点击 Edit variables。点击 New variables，把刚才. env 里面的 4 个变量分别填进去就行了。类似这样：

![](https://www.dreamsafari.info/uploads/2020/04/netlify.jpg)

之后，修改根目录下 netlify.toml，把 {?\[}build\] 下面的 command 行修改为：

```
{{- $index := slice -}}
{{- range $page := $.Site.RegularPages -}}
  {{- $cleaned := slice -}}
  {{- $cleaned = $page.Plain}}
  {{- $cleaned = replace $cleaned "\\r" ""}}
  {{- $cleaned = replace $cleaned "\\n" ""}}
  {{- $cleaned = replace $cleaned "\\u0026rsquo;" "'"}}
  {{- $cleaned = replace $cleaned "\\u0026amp;" "&"}}
  {{- $cleaned = replace $cleaned "\\u0026#34;" "\\""}}
  {{- $cleaned = replace $cleaned "\\u0026#39;" "'"}}
  {{- $cleaned = replace $cleaned "\\u0026ndash;" "-"}}
  {{- $cleaned = replace $cleaned "\\u0026gt;" ">"}}
  {{- $cleaned = replace $cleaned "\\u0026quot;" "\\""}}
  {{- $cleaned = replace $cleaned "\\u0026ldquo;" "“"}}
  {{- $cleaned = replace $cleaned "\\u0026rdquo;" "”"}}
  {{- $chunked := slice -}}
  {{- $chunked = $chunked | append (substr $cleaned 0 500) -}}
  {{- if gt (countwords $cleaned) 500 }}
    {{- $chunked = $chunked | append (substr $cleaned 500 500) -}}
  {{- end -}}
  {{- if gt (countwords $cleaned) 1000 }}
    {{- $chunked = $chunked | append (substr $cleaned 1000 500) -}}
  {{- end -}}
//
// 中间省略，大家根据自己blog的长短来决定写多少行吧。建议直接写一个脚本或者用Excel生成……
//
  {{- range $i, $c := $chunked -}}
    {{- $index = $index | append (dict "objectID" (print $page.File.UniqueID "\_" $i) "content" $c "order" $i "title" $page.Title "date" $page.Date "url" $page.Permalink "tags" $page.Params.tags "categories" $page.Params.Categories) -}}
  {{- end -}}
{{- end -}}
{{- $index | jsonify -}}
```

这样，下次更新完博客之后，netlify 就会自动生成索引，并且提交给 Algolia 了。

### [](#25-为主题增加搜索页)[2.5 为主题增加搜索页](#contents:25-为主题增加搜索页)

这部分吧，主要难点在修改 css…… 熟悉我的都知道我是个学财务和金融做咨询的，~体健貌端思想开放~，技术宅只是业余爱好。好在做咨询的，对于 Google 的使用还算略有一些心得。摸爬滚打误打误撞之后，居然也给我改出来了……

之前解决了我们分割记录问题的哥们也[给了一个代码](https://www.bennet.org/blog/site-search-jamstack-hugo-algolia/)，做出了一个**电脑上**挺好用的即时搜索框。可惜这个框在手机上不太好用，所以我决定还是新建一个搜索页，专门用来搜索吧。

首先，在 / content 下面新建一个 search.md 文件，内容如下：

日期设置为 1970 年的原因是搜索页面在输入关键词前，会显示最近更新的 10 篇文章。这样设置可以避免搜索的时候先显示了这篇文章。

然后，在 / layouts 下新建 static 文件夹，放入 search.html。这个文件比较大，就不贴在这里了[点这里下载](https://github.com/dreamsafari/LoveIt/blob/master/layouts/static/search.html)。

接下来是修改 css，否则的话这个搜索丑丑的。我直接用了 Algolia 给的示例主题进行修改。文件太大我也不贴了，[点这里下载](https://github.com/dreamsafari/LoveIt/blob/master/assets/css/_page/_search.scss)之后放在 / assets/css/\_page 中。记得修改\_index.scss 文件来引入\_search.scss

最后，需要在导航栏中引入搜索页。这个超级简单，直接在 config.toml 中增加一项 \[\[menu.main\]\]：

```
npm init
npm install atomic-algolia --save-dev
```

完成之后，搜索部分就搞定啦！

[](#3-pwa)[3\. PWA](#contents:3-pwa)
------------------------------------

PWA 纯粹是，好玩…… 是我在看 [hugo-theme-meme](https://github.com/reuixiy/hugo-theme-meme) 的时候发现的。所以，具体过程[参考这篇文章](https://io-oi.me/tech/pwa-via-workbox/)就行了。

说几个需要注意和修改的地方：

1.  因为之前生成了 algolia.json，如果内容多的话，这个文件还挺大的。虽然我不知道这个文件会不会被缓存，但是考虑到我其实并没有其他用到 json 的地方，所以我还是决定在 gulpfile.js 里面的 globPatterns 部分删掉了 json。
    
2.  我增加了 [Google 的 PWA Compact](https://github.com/GoogleChromeLabs/pwacompat)，可以自动根据 manifest.webmanifest 来生成各种东西支持其他浏览器。这么做需要修改 / layouts/partials/head/link.html，增加下面这一行：
    
    记得检查一下，link.html 里面那个 manifest 文件的文件名是否和 / static 里面的文件名一致。具体叫 manifest.json 还是 site.webmanifest 还是 manifest.webmanifest 无所谓，只要文件名一致就行。
    
3.  注册 Service Worker 和提醒的代码我放在了 / layouts/partials/footer.html 里面，照抄就行。
    
4.  CSS 脚本我原封不动地放在了 / assets/css/\_core/\_pwa.scss 里面，然后记得修改 / assets/css/style.template.scss 来引入增加的 scss 文件。
    

老规矩，测试通过之后可以交给 Netlify。还是修改 netlify.toml 文件，增加命令。和 Algolia 搜索的相关命令整合之后，这个文件现在长这样：

```
"scripts": {
  "test": "echo \\"Error: no test specified\\" && exit 1",
  "algolia": "atomic-algolia"
},
```

更新成功之后，可以用 [Lighthouse](https://developers.google.com/web/tools/lighthouse) 来检查一下。如果提示有任何错误，修正即可。

由于众所周知的原因，国内现在访问不了 disqus，和一些其他的网站了。所以除了科学上网之外，还需要科学评论…… 采用的方案是 [SukkaW/DisqusJS](https://github.com/SukkaW/DisqusJS)。这是一个超轻量级的代理，可以自动检测访客的 Disqus 可用性，自动选择加载原生 Disqus（评论完整模式）和 DisqusJS 提供的评论基础模式。

Disqus 代理的另外一个选项是 [szhielelp/disqus-proxy](https://github.com/szhielelp/disqus-proxy)。这个方案的优点是可以匿名评论，可是 deal breaker 是他用了 bootstrap CSS，会和主题的 CSS 冲突。因此作为一个懒人，我断然决定放弃。

DisqusJS 部署起来超级简单，我后端用 [ZEIT Now](https://zeit.co/)，只需要一个 now.json 文件就行了。不需要下载 now 的教程[参照这里](https://github.com/SukkaW/disqusjs-proxy-example)。看上去只需要部署一次，一劳永逸。

前端的话，也不复杂，只需要在 config.toml 里面增加几个变量，然后动一动 / layouts/partials/comment.html 这个文件就行了。

config.toml 增加的变量：

```
ALGOLIA\_APP\_ID={{ YOUR\_APP\_ID }}
ALGOLIA\_ADMIN\_KEY={{ YOUR\_ADMIN\_KEY }}
ALGOLIA\_INDEX\_NAME={{ YOUR\_INDEX\_NAME }}
ALGOLIA\_INDEX\_FILE=public/algolia.json
```

变量说明：

/layouts/partials/comment.html 的修改：在`<div></div>`下面插入这段代码：

这里没有引入 [DisqusJS 默认 CSS](https://github.com/SukkaW/DisqusJS/blob/master/src/disqusjs.css) 的原因是，LoveIt 会根据系统设置启用夜晚模式，而夜晚模式下 DisqusJS 的默认颜色就比较刺眼了。解决方式是[下载这个文件](https://github.com/dreamsafari/LoveIt/blob/master/assets/css/_partial/_single/_disqusjs.scss)，保存到 / assets/css/\_partial/\_single/，最后在同目录下的\_comment.scss 最后增加一句代码`@import "_disqusjs.scss";`来引入修改之后的 scss 文件。

需要提一下的是，默认在 development 环境下 LoveIt 是不会渲染 Disqus 的。所以要么直接在 production 里面测试，要么暂时把`{{- if $scratch.Get "production" | and (ne .Site.Params.comment.enable false) | and (ne .Params.comment false) -}}`里面的 production 改成 development。部署之前记得改回来就好。

[](#5-懒人方案)[5\. 懒人方案](#contents:5-懒人方案)
---------------------------------------

说了那么多，如果上面这些功能都想要的话，我在 GitHub 上面 [fork 并修改了 LoveIt 的源码](https://github.com/dreamsafari/loveit)，直接用`git submodule add --depth 1 https://github.com/dreamsafari/loveit.git themes/LoveIt`，然后修改 config.toml 即可。

[](#6-后话)[6\. 后话](#contents:6-后话)
---------------------------------

选择 LoveIt 这个主题，很大一部分的原因是因为[丰富的 Shortcodes 支持](https://hugoloveit.com/zh-cn/theme-documentation-shortcodes/)。考虑到我目前心水 [hugo-theme-meme](https://github.com/reuixiy/hugo-theme-meme) 这个主题，所以估计接下来一段时间里面，如果有空的话，会尝试一下能不能把 Shortcodes 和这些功能移植到 meme 上面吧…… 关于这些功能在 LoveIt 上面的实现，如果有问题的话大家在下面留个言吧。

updatedupdated2020-07-102020-07-10